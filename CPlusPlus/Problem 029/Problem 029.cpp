/*
Project Euler
Problem 29

Consider all integer combinations of ab for 2 <= a <= 5 and 2 <= b <= 5:

    2^2=4,  2^3=8,   2^4=16,  2^5=32
    3^2=9,  3^3=27,  3^4=81,  3^5=243
    4^2=16, 4^3=64,  4^4=256, 4^5=1024
    5^2=25, 5^3=125, 5^4=625, 5^5=3125

If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by ab for 2 a 100 and 2 b 100?
*/

// note that we won't be able to calculate this directly.  100^100 is way too big (unless we want to use a bigint implementation).
// instead, note that the only way for things to collide is for their prime factorizations to be the same
// so, this problem reduces to finding numbers with the same prime factorization
// we'll use std::map to map a pair of numbers <base, exponent> to a vector of pairs <base, exponent> representing the factorization
// then implement a comparator to see if the vector of pairs is identical

// A MUCH shorter solution is just to calculate b*log(a), because if a^b is unique then log(a^b) = b*log(a) is unique
// Also, double has enough precision over the given range to calculate it no problem

#include <iostream>
#include <vector>
#include <map>
#include <algorithm>

typedef std::vector<std::map<int, int>> factor_list;


int main (void)
{
	factor_list nums;

	// now go through each possible combination and factorize the result
	for(int base = 2; base<=100; ++base)
	{
		for (int exponent=2; exponent<=100; ++exponent)
		{
			// factorize
			std::map<int, int> factors;

			int temp = base;
			for (int divisor = 2; divisor <= temp; ++divisor)
			{
				if (temp == 1)
					break; // we've already completely factored temp

				// otherwise, see if divisor divides it
				if (temp % divisor == 0)
				{
					if (factors.find(divisor) != factors.end())
					{
						factors[divisor] += exponent;
					}
					else
					{
						factors[divisor] = exponent;
					}
					temp /= divisor;
					divisor = 1;
				}
			}

			// go ahead and add it to the vector
			nums.push_back(factors);
		}
	}

	// attempt to sort the contents
	factor_list::iterator first = nums.begin();
	factor_list::iterator last = nums.end();
	sort(first, last);

	// now do the world's most inefficient sort ever
	int count = 0;
	for (factor_list::iterator i = nums.begin(); i!= nums.end(); ++i)
	{
		
		if (i+1 != nums.end())
		{
			if (*i != *(i+1))
				++count;
		}
		else
			++count;
	}

	std::cout << count << std::endl;


	return 0;
}