/*
Project Euler
Problem 45

Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

Triangle   Tn=n(n+1)/2   1, 3, 6, 10, 15, ...
Pentagonal Pn=n(3n-1)/2  1, 5, 12, 22, 35, ...
Hexagonal  Hn=n(2n-1)    1, 6, 15, 28, 45, ...

It can be verified that T285 = P165 = H143 = 40755.

Find the next Triangle number that is also pentagonal and hexagonal.
*/
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;

namespace Problem_045
{
    class Program
    {
        static void Main(string[] args)
        {
            // TODO: verify that the test case works.
            //Debug.Assert(IsAllThree(40755));

            IEnumerator<Int64> triangles = new Triangular().GetEnumerator();
            IEnumerator<Int64> pentagons = new Pentagonal().GetEnumerator();
            IEnumerator<Int64> hexagons = new Hexagonal().GetEnumerator();

            // test case
            Int64 num = GetNextMatch(triangles, pentagons, hexagons);
            Debug.Assert((triangles.Current == 1) && (pentagons.Current == 1) && (hexagons.Current == 1));
            num = GetNextMatch(triangles, pentagons, hexagons);
            Debug.Assert((triangles.Current == 40755) && (pentagons.Current == 40755) && (hexagons.Current == 40755));

            // now the real case
            num = GetNextMatch2(pentagons, hexagons);

            Console.WriteLine("***** " + num.ToString() + " *****");
            Console.ReadLine();
        }

        static Int64 Max(Int64 a, Int64 b, Int64 c)
        {
            Int64 temp = (a > b ? a : b);
            return (temp > c ? temp : c);
        }

        static Int64 Max2(Int64 b, Int64 c)
        {
            return (b > c ? b : c);
        }

        static Int64 GetNextMatch(IEnumerator<Int64> a, IEnumerator<Int64> b, IEnumerator<Int64> c)
        {
            a.MoveNext(); // to make sure we move past the current match

            Int64 max = Max(a.Current, b.Current, c.Current);
            while ((a.Current != b.Current) || (a.Current != c.Current))
            {
                Console.WriteLine(String.Format("{0,10} {1,10} {2,10}", a.Current, b.Current, c.Current));
                while (a.Current < max)
                    a.MoveNext();
                while (b.Current < max)
                    b.MoveNext();
                while (c.Current < max)
                    c.MoveNext();

                max = Max(a.Current, b.Current, c.Current);
            }

            return max;
        }

        static Int64 GetNextMatch2(IEnumerator<Int64> b, IEnumerator<Int64> c)
        {
            b.MoveNext(); // to make sure we move past the current match

            Int64 max = Max2(b.Current, c.Current);
            while (b.Current != c.Current)
            {
                Console.WriteLine(String.Format("{0,10} {1,10}", b.Current, c.Current));
                while (b.Current < max)
                    b.MoveNext();
                while (c.Current < max)
                    c.MoveNext();

                max = Max2(b.Current, c.Current);
            }

            return max;
        }
    }

    abstract class NumberSequence : IEnumerable<Int64>
    {
        public IEnumerator<Int64> GetEnumerator()
        {
            return new NumberSequenceEnumerator(this);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return new NumberSequenceEnumerator(this);
        }

        protected abstract Int64 GetNum(Int64 index);

        class NumberSequenceEnumerator : IEnumerator<Int64>
        {
            private Int64 index = 0;
            private Int64 cachedNum = 0;
            private NumberSequence seq;

            public NumberSequenceEnumerator(NumberSequence enumerable)
            {
                seq = enumerable;
            }

            public void Reset()
            {
                index = 0;
            }

            public bool MoveNext()
            {
                ++index;
                cachedNum = seq.GetNum(index);
                return true;
            }

            public Int64 Current { get { return cachedNum; } }

            object IEnumerator.Current { get { return cachedNum; } }

            public void Dispose()
            {
            }
        }
    }

    class Triangular : NumberSequence
    {
        protected override Int64 GetNum(Int64 index)
        {
            return index * (index + 1) / 2;
        }
    }

    class Pentagonal : NumberSequence
    {
        protected override Int64 GetNum(Int64 index)
        {
            return index * (3 * index - 1) / 2;
        }
    }

    class Hexagonal : NumberSequence
    {
        protected override Int64 GetNum(Int64 index)
        {
            return index * (2 * index - 1); 
        }
    }

}
